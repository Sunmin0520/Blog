---
title: '[CS][OS] 프로세스의 실행을 위한 CPU 스케줄링'
date: 2022-04-30 13:15:07
category: 'cs'
draft: false
---

# 1. 스케줄링

- CPU 스케줄링
    - 모든 프로세스가 공평하게 작업할 수 있도록 여러 프로세스의 상황을 고려 → 어떤 작업에 CPU와 시스템 자원을 배분할지 결정
    - 프로세스 생성~종료동안의 모든 상태 변화를 조절
    - CPU 스케줄러 = 프로세스 스케줄러

### 규모에 따른 분류

<img src="https://user-images.githubusercontent.com/79896443/173210607-5e9428d5-fc5e-4a18-bef5-126c8f726ca9.png" width="1000">

- **고수준 스케줄링** = 장기 스케줄링 = 작업 스케줄링 = 승인 스케줄링
    - 어떤 작업을 시스템에서 받아들일지 말지 결정 → 시스템 내에서 동시에 실행 가능한 **프로세스 수 결정**
    - 규모가 큰 일괄 작업 처리시 사용
- **중간 수준**
    - 고수준과 저수준 사이에서 작동. 전체 시스템의 활성화된 프로세스 수 조절 → 완충 역할
    - 과부하 발생시, 이미 활성화된 프로세스를 보류 상태로 보내고, 여유 생길 때 다시 활성화
- **저수준** = 단기 스케줄링
    - 준비 → 실행/ 실행 → 대기/ 대기 → 준비 등을 결정하는 것 [프로세스와 스레드 학습 정리 링크](https://sunmin.netlify.app/CS/OS/3.process_and_thread/)
    - 실제 작업이 이루어지는 단계

### 스케줄링 목적

- 공평:모든 프로세스가 자원을 배정. 하지만 안정성과 효율성 위해 우선 순위 둔다.
    - 우선순위 높다 = 더 빨리 자주 실행된다.
    - 운영체제 프로세스는 일반 프로세스보다 우선 순위 있음
- 효율: 시스템 자원을 사용
- 안정: 우선순위 있는 중요 프로세스가 먼저 작동
- 확장: 프로세스가 증가해도 시스템이 안정적으로 작동
- 반응 시간 보장: 시스템은 적절한 시간 내에 사용자에게 응답 필요
- 무한 연기 방지: 특정 프로세스의 작업이 무한히 연기되어서는 안됨

# 2. 스케줄링할 때 고려해야할 사항

### 1. 선점형 스케줄링, 비선점형 스케줄링

- 선점형
    - 실행 상태여도 중단시키고, 새로운 작업 실행 가능(실행상태의 프로세스여도 필요시 운영체제가 강제로 CPU를 빼앗을 수 있음)
    - 문맥 교환은 생기지만, 한 프로세스가 CPU 독점 X → 시분할, 대화형 시스템에 적합  → 요즘 주로 사용됨
- 비선점형
    - 실행 상태의 작업 완료시까지 기다려야함
    - 일괄작업방식 → 요즘과는 맞지 않아서 지금은 거의 사용되지 않음

### 2. 우선 순위

- **우선순위 높을수록 CPU 먼저 할당**
    - 우선 순위 ⬆️ : 커널 프로세스, 전면 프로세스, 입출력 집중 프로세스, 대화형 프로세스
    - 우선 순위 ⬇️ : 일반 프로세스, 후면 프로세스,  CPU 집중 프로세스, 일괄 작업 프로세스
    - 프로세스에 따라 대화형인지 일괄작업인지, 입출력 집중인지 CPU 집중인지를 명확하게 구분하기 어려울 수도 있다.
- 일반 프로세스의 우선순위는 사용자가 조절 가능

### 3. CPU 집중 프로세스, 입출력 집중 프로세스

- 입출력 프로세스는 실행 → 대기 상태로 이동하므로, 그동안 다른 프로세스가 CPU 사용 가능

⇒ 스케줄링시 우선순위를 **입출력 집중 프로세스 > CPU 집중 프로세스** 로 하면(cycle stealing) 효율 상승

### 4. 전면 프로세스, 후면 프로세스

- 전면 프로세스 ( = 상호작용 프로세스) : GUI에서 화면의 맨 앞에 놓인 프로세스. 즉 현재의 입출력 담당
- 후면 프로세스 ( = 일괄 작업 프로세스) : 사용자와의 상호 작용 현재 없음

# 3. 준비, 대기 상태에서 다중 큐

### 1. 준비상태

- 프로세스가 우선순위에 따라 각 우선순위에 해당하는 큐에 들어감
    - 우선순위는 PCB 참고
    - 큐에서 한번에 하나의 프로세스 꺼내서 dispatch
- 방식
    - 고정 우선 순위: 운영체제가 프로세스에 부여한 우선 순위가 프로세스 끝날 때까지 고정 → 변화에 적응 어려움
    - 변동 우선 순위: 우선순위 변동 가능
        - 반전 우선 순위: 우선순위 낮은 것을 높게 바꾸는 것 → 효율성 향상
        

### 2. 대기 상태

- 같은 입출력 요구한 프로세스끼리 모아놓음
- 동시에 여러 인터럽트가 끝날 수 있고, 그것을 처리하기 위해 인터럽트 벡터(인터럽트의 집합) 사용
    - 준비큐와 달리 여러 개의 PCB를 동시에 꺼내서 준비 상태로 옮김
    
    <img src="https://user-images.githubusercontent.com/79896443/173210328-831f1edf-d8f5-42bd-8e37-4313df01baad.jpg" width="450">

# 4. 스케줄링 알고리즘의 종류

- 비선점형: FCFS, SJF, HRN 스케줄링
- 선점형: 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐 스케줄링
- 둘 다: 우선 순위 스케줄링(SJF, HRN, SRT)

## 스케줄링 알고리즘의 효율성 평가 기준

- CPU 사용률: 전체 시스템 동작 시간 중 CPU가 사용된 시간 측정
- 처리량: 단위 시간당 작업 마친 프로세스 수
- **대기 시간**: 작업 시작 전까지 대기하는 시간
    - 평균 대기 시간: 모든 프로세스의 대기 시간 합 / 프로세스 수
        - 스케줄링 알고리즘 성능 비교시에는 주로 평균 대기 시간으로 판단하지만, 
        작업 패턴에 따라 대기시간이 변경되기도 함을 감안해야함
- **응답 시간**: 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간
- **반환 시간**: 프로세스 생성 및 종료 후 사용하던 자원 모두 반환 때까지 걸리는 시간
    
    <img src="https://user-images.githubusercontent.com/79896443/173210329-7173bf21-ec7b-4889-9888-2f791889f70b.jpg" width="500">
    

## 비선점형 알고리즘의 종류

### FCFS ( First Come First Served)

  <img src="https://user-images.githubusercontent.com/79896443/173210330-4b2a19b1-59f8-4bfa-9f45-ef7490a940ac.jpg" width="450">

- 큐가 하나 → 모든 프로세스의 우선 순위 동일
- 단점:현재 작업 중인 프로세스가 입출력 요청시 CPU가 작업하지 않고 쉬는 시간 많다 → 작업효율 저하
    - 시분할시스템에서는 대기 상태로 보내서 효율 향상

### SJF (Shortest Job First)

- 실행시간 짧은 것에 우선순위
- 단점
    - 과거의 일괄작업 프로세스와 달리 요즘은 상호작용 많다 → SJF로는 프로그램 종료 시간 예측 어려움
    - 작업시간이 길다는 이유만으로 계속 밀릴 수 있다.

### HRN (Highest Response Ration Next)

- 우선순위 =(대기 시간+CPU 사용시간) /  CPU 사용시간
- SJF에 비해서는 개선되었지만 여전히 공평성 위배

## 선점형 알고리즘의 종류

### Round Robin (순환 순서 방식)

  <img src="https://user-images.githubusercontent.com/79896443/173210332-3b57805e-824e-4b13-bfa0-fa1aa3fd7cca.jpg" width="450">

- 타임슬라이스동안 작업하고, 만약 작업 완료 못하면 준비 큐의 맨 뒤로 가서 기다림.
- **프로세스들이 작업 완료할 때까지 계속 순환하며 기다리는 방식**
- 우선순위 없음
- 단점: 타임슬라이스가 너무 크면 FCFS와 비슷, 너무 작으면 문맥교환에 시간 낭비 많음
    - 유닉스에서는 타임슬라이스가 대략 100밀리초
        - 오늘날에는 다단계 피드백 큐 스케줄링 사용하고, 그 과정에서 10~200 밀리초 사이에서 조정 가능

### SRT (Shortest Remaining Time) = SJF + 라운드로빈

- 실행될 때까지 남은 시간 적은 것 기준으로 우선순위 잡고, 타임슬라이스동안 작업
- 단점: 프로세스 종료 시간 예측 어렵고 공평성 부족

### 다단계 큐 스케줄링

  <img src="https://user-images.githubusercontent.com/79896443/173210333-1fbad092-3a2c-42ea-9334-9ac63a39659c.jpg" width="450">

- 우선순위에 따라 준비 큐를 여러개 사용
- 라운드 로빈 + 우선순위

### 다단계 피드백 큐 스케줄링

  <img src="https://user-images.githubusercontent.com/79896443/173210334-68692ca7-40e0-44bb-b1f8-a137d4ecb2fb.jpg" width="450">

- 다단계 큐 스케줄링 + 우선순위 낮은 프로세스에게 불리한 점 해결
- CPU 사용하고 난 프로세스의 우선 순위가 낮아짐 → CPU 사용하고 난 프로세스는 원래의 큐가 아닌 **우선 순위 하나 낮은 큐로 들어감**
    
    → 우선 순위 낮은 프로세스의 실행 기회 확대
    
    - 그럼에도 우선순위 높은 프로세스보다 CPU 얻을 확률 낮기에, 타임슬라이스를 무한대로 설정
- **오늘날의 운영체제가 CPU 스케줄링 위해 일반적으로 사용하는 방식**

# 5. 인터럽트

- **폴링과 대비되는 입출력 시스템. 입출력을 요청하고 입출력이 완료되면 이벤트를 발생시켜서 알림**
    - CPU가 입출력 명령 내리면, 입출력장치는 작업 마친 후, 완료 신호를 CPU에 보냄
    
### 분류
- 동기 vs 비동기(명령어의 실행 vs 명령어와 무관) 로 나누는 관점
  - 동기적 인터럽트 (= 사용자 인터럽트) : 프로세스가 실행 중인 명령어 때문에 발생
      - 프로그램상의 문제(다른 사용자의 메모리 영역에 접근, 오버플로 언더플로 등)
      - 사용자가 의도적으로 프로세스 중단 위해 인터럽트 발생
      - 입출력장치 조작, 산술 연산 등
  - 비동기적 인터럽트: 명령어와 무관하게 발생
      - 하드디스크 읽기 오류, 메모리 불량, 키보드 인터럽트, 마우스 인터럽트 등

- 외부 vs 내부(하드웨어 vs 소프트웨어)로 나눌 수도 있음 [관련 학습 정리 링크](http://sunmin.netlify.app/CS/OS/10.input_output_system_and_storage_devices/)
    

### 인터럽트 처리

- 인터럽트 번호 + 그 번호에 매칭된 함수(인터럽트 핸들러) 쌍
    - **인터럽트 벡터**: 인터럽트와 인터럽트 핸들러를 1:1로 연결한 자료 구조로 묶어서 처리
- 인터럽트 발생 → 해당 프로세스는 일시정지 → 인터럽트 컨트롤러 실행되어 인터럽트 처리 순서 결정 → 처리 순서 결정되면 인터럽트 벡터에 등록된 인터럽트 핸들러 실행 → 핸들러가 인터럽트 처리하면 일시 정지됐던 프로세스가 필요에 따라 다시 실행이나 종료됨

### 이중 모드

- 커널 모드: 운영체제와 관련된 커널 프로세스가 실행되는 상태
- 사용자 모드: 사용자 프로세스(실행 중인 프로그램)가 실행되는 상태
    - 사용자 프로세스를 단순히 프로세스라고 하기도 하며, 이를 커널이 관리
- 사용자 모드에서 커널의 기능(하드디스크 입출력, 프로세스 생성 등) 이용 위해 **시스템 호출**을 이용
    - 시스템호출: 응용 프로그램에서 필요시,  커널에 접근 위한 인터페이스
    - 사용자 프로세스는 시스템 호출 요청 후 대기 상태 되고, 커널 프로세스는 요청받은 작업 처리
        - 이중 모드:  위와 같이 운영체제가 두 모드를 전환하며 일처리 하는 것
            - 목적: 커널로의 직접적 접근 방지
- **프로세스의 실행 위해 사용자가 커널 모드로 진입하는 경우는 시스템호출(자발적), 인터럽트 발생(비자발적) 2가지**

<br/>

## 출처
- 조성호, 쉽게 배우는 운영체제(한빛아카데미, 2022)