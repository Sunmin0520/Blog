---
title: 'RDBMS, NoSQL, 분산 데이터베이스'
date: 2021-02-22 12:18:13
category: 'Database'
draft: false
---

<p>

## 1. 관계형 데이터베이스

### 용어
- table표, row행, column(field)
- schema: 필드와 제약 사항을 정해둔 것
- 관계형DB에서는 **동일한 규칙과 제약사항 따르는 데이터**만 저장됨 
  - 거대한 구조의 데이터를 다루는 상황에서 고정된 스키마 사용 -> 저장된 데이터가 올바른 형식임을 보장 
  - 개별적인 특질이 너무 강하면 관계형 DB 부적합 가능
  
<br />

- **primary key 기본키** : 모든 표에는 식별 위한 ID 필드 있고, 이 값은 그 표 안에서 고유해야한다. 이 값으로 행을 식별
- **foreign key 외래키** : 다른 행의 ID값을 저장하여 참조하는 필드
  
<br />

- JOIN을 통해 중복정보를 제거(기본키, 외래키의 사용)
- **정규화 normalization** - 표를 나누고 **중복정보를 제거**하는 변환 과정
  - 어떤 DB에 중복되는 정보가 전혀 없도록 해두면 그 DB는 완전히 정규화된 것

### Schema migration 스키마이전
- 스키마 변경 및 수정작업 위해 스키마 마이그레이션 스크립트 작성
- 롤백하는 내용도 일반적으로 함께 작성
- DBMS에서는 보통 스키마 마이그레이션 도구 함께 제공

### SQL
- RDBMS는 대부분 SQL지원
- JOIN은 비용이많이 든다. 최악의 경우 조인하는 표들의 모든 결합 예상해야함 => JOIN은 RDBMS의 가장 큰 장점이면서도 취약점

### Index 인덱스, 색인
- 각 행의 id와 메모리 속 주소를 대응 -> 해당 항목 빠르게 조회
- 균형 이진 탐색 트리로 구성. 각 노드의 키가 찾아야하는 행의 id값. O(log n)으로 탐색 가능
- 기본적으로는 모든 Primary key에 대해 인덱스 생성 (NoSQL에서도 동일)
- 특정 필드 이용해 검색 자주 하면 그 필드에 대한 인덱스 추가로 생성하게 스키마 생성할 수 있음
  
<br />

- **고유 필드(중복값이 허용되지 않는 필드)** : 중복 없애기 위해 모든 행 확인 필요 -> 고유필드에서는 자동으로 인덱스 생성이 일반적
- **정렬** : 2개 이상의 필드를 기준으로 정렬시 여러 필드 묶어 joint index 공동색인 활용 가능
- **성능** : 모든 필드에 색인이 있다면 데이터의 CRUD일어날 때 색인도 이를 반영해야함 -> 어떤 색인 남겨두고, 버릴 것인지 판단 필요
  - 분석 도구 활용하여 성능차이 날 때만 색인 추가할 것

### 트랜잭션 
- 여러 단계로 이루어진 연산을 모두 온전히 수행 or 아무 연산도 수행 없이 데이터 그대로 둠. **원자적으로 수행하고자 하는 DB연산들을 나열한 것**

## 2. NoSQL
- RDBMS가 데이터(중복 제거 및 짜임새있게 조작)에 중심, 응용프로그램에서 어떻게 사용할 것인지는 보다 덜 관심이라면 NoSQL은 반대
- 표를 이용 X, 여러 데이터 항목의 결합 거의 X
- 방대하고 불안정하고 구조가 일정하지 않은 데이터를 빠르고 효율적으로 다룸
- 고정된 스키마나 스키마 마이그레이션에 대한 걱정 없이 개발
- 정보의 일관성 위해 중복 정보 갱신 부담 있음

### Document store 문서 저장소 
- RDBMS기준에서는 중복이 되는 데이터들도 하나의 document문서로, 서로 연관된 문서는 collection으로 묶어둠
- 장점
  - 관련 정보 얻기 위해 JOIN 할 필요 없다.
  - 고정된 스키마 불필요
  - 각 데이터 항목에 서로 다른 필드 지정 가능

### key-value store 키-값 저장소
- 데이터를 조직적이고 일관적으로 저장하는 가장 단순한 방식. 다른 DB에 비해 key-value store가 유의미하게 우수한 것은 캐시가 매우 빈번하게 요청될 때뿐.
- 주로 캐시에 사용
  - 예: { 특정URL: 그 URL에 대응하는 웹페이지에 필요한 데이터를 DB에서 가져온 뒤 그 데이터를 HTML로 가공해둔 것 }
  - 시간 오래 걸리고 항상 동일한 결과 출력하는 연산에 효과적  

### 그래프 데이터베이스
- 고정된 스키마 제약 없이 데이터들의 관계를 엣지로 저장(항목들의 연결망 작성에 유용)
- 데이터가 네트워크 형태, 각 항목 사이에서 나타내야할 중요한 관계가 많다면 특히 유용

### 빅 데이터
- 3V(Volume, Velocity, Variety) 측면에서 다루기 까다로운 상황
- NoSQL은 보다 유연한 데이터 처리 지원 -> 빅데이터는 NoSQL 쓰는 경향 많다.

## 3. 분산 데이터베이스
- 일부 DBMS는 서로 연결된 컴퓨터들 위에서 분산데이터베이스 시스템을 구성하고, 이를 위한 방법에는 레플리케이션, 샤딩 등등이 있다.
  
### Single-master replication 단일 마스터 레플리케이션
- 한 마스터 있고 마스터에서 쿼리 요청받고, 연결된 여러 슬레이브에 복제본 동기화 
- 쿼리 양이 엄청나다면 싱글 마스터로 부하 감당 어려움 => 다중 마스터 레플리케이션 이용
  
### 다중 마스터 레플리케이션
- 클러스터 구성하는 **모든 컴퓨터를 마스터**로 삼고, **load balancer**부하분산기 를 통해 질의 나눠받음
- 각 컴퓨터는 클러스터의 다른 모든 컴퓨터와 연결, 전체 DB의 사본도 모든 컴퓨터가 각자 보유
- 대용량의 쓰기 질의가 대량 발생시 클러스터 곳곳의 DB사본 동기화도 어려움 가능 => 샤딩 이용

### Sharding 샤딩
- **DB를 여러 컴퓨터에 조각내어 저장**하는 방법. 그 각 분할본은 shard 라고 함.
- 컴퓨터마다 갖고 있는 부분 다름 -> query router 통해 필요한 샤드로 쿼리 전달함
- 클러스터 구성하는 컴퓨터 중 하나라도 중지시 해당 DB를 아예 못 쓰게 될 수도 있다. => 샤딩과 레플리케이션 병행해서 각 분할본마다 마스터-슬레이브 클러스터 운영

### 데이터 일관성
- 레플리케이션 방식의 분산 DB에서 클러스터 구성하는 모든 컴퓨터의 동기화에는 시간 소요 -> 데이터의 일관성 깨질 수 있다.(data inconsistency)
- 일관성과 성능은 반비례할 수밖에 없다. 질의 수행시 일관성을 강력히 강제하도록 하지 않는 것은 eventual consistency결과적 일관성 하의 작업

## 4. 정보 교환 위한 직렬화 방식
- 데이터를 데이터베이스 외부에 저장해야할 떄도 있다. (백업, 다른 시스템에 보내는 등등) => 데이터를 serialization직렬화하여 특정 부호화 형식으로 변환
- 직렬화 방법
  - SQL: RDBMS의 직렬화에 가장 많이 사용/대부분의 RDBMS는 dump(DB를 SQL직렬화 파일로 저장하는 명령) & restore 기능 제공
  - XML: 관계형 뿐만 아니라 다양한 시스템에서 호환
  - JSON: 관계형, 비관계형 모두 호환되며 가장 친숙하고 직관적/BSON, JSONLD등의 변형판도 있다.
  - CSV: 콤마로 한 행씩 구분하며 데이터 보냄. 간단한 데이터 보낼 때 유용

<br />
<br />

**출처** 블라드스톤 페헤이라 필루, 컴퓨터 과학 로드맵(인사이트, 2018)

</p>