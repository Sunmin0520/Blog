---
title: '[CS][OS] 입출력 시스템과 저장장치'
date: 2022-06-12 10:13:07
category: 'cs'
draft: false
---

# 1. 입출력 시스템

### 버스, 채널

- 컴퓨터 = 프로세서(CPU) + 메모리 + 주변장치(입출력장치, 저장장치)
- 버스: 여러 주변장치는 버스로 연결 / 채널: 한 버스의 통로(채널 수만큼의 주변장치가 동시에 데이터 주고 받음)
    - 속도 비슷한 장치끼리 묶고, 그 단위별로 채널 할당 → 전송 속도 향상
- 주변장치의 데이터전송 속도에 따라 고속과 저속으로 분류해서 채널을 사용
    - 그래픽카드의 전송 속도와  용량은 입출력버스로는 처리 x → 메인버스에 그래픽카드 전용 포트인 AGP로 연결
    - 고속과 저속 버스 **사이의** 데이터 전송은 **채널 선택기**가 관리하고, 두 버스를 **모두** 관리하는 것은 **입출력제어기**
    - **CPU의 도움 없이도** 입출력제어기가 **메모리에 직접 접근이 가능**하도록 **DMA 제어기** 있음
        - DMA 제어기가 사용하는 메모리의 영역과 CPU의 작업 공간으로서의 메모리 분리(**memory mapped I/O 구조**)
    
      <img src="https://user-images.githubusercontent.com/79896443/173210040-7231ca70-6590-4d61-98c5-34da413e9667.jpg" width="500">


### 인터럽트

- I/O 작업 완료시 입출력제어기는 CPU에 **각 장치의 고유인터럽트번호인** **IRQ**(interrupt requset)와 함께 인터럽트 보냄
    - 인터럽트 분류
        - 외부 인터럽트(하드웨어 인터럽트): 입출력장치로부터의 인터럽트, 하드웨어 이슈로 오는 인터럽트
            - CPU에 IRQ번호와 인터럽트 번호(32~47 중 하나)를 모두 전달
        - 내부 인터럽트(exception interrupt): 프로세스 이용 중의 오류로 인한 인터럽트
            - 발생시(인터럽트 번호는 0~31 중 하나) 프로세스 즉시 종료되고, 종료 직전까지의 메모리와 레지스터 상태를 저장하는 **코어 덤프** 통해 상황 파악 가능
        - 시그널: 사용자 요청으로 인한 인터럽트
            - 인터럽트 번호는 128이고, 세부 시그널 번호 명명

### 버퍼

- 버퍼: 속도가 다른 두 장치의 속도차이를 완화(쌓아뒀다가 한번에 데이터 가져감)
    - 주변 장치에서는 **입출력 제어기와 입출력 장치 사이에 버퍼가 있음**
        - 이중버퍼double buffer로 하나에서는 데이터 담고, 다른 하나에서는 데이터 가져감

# 2. 디스크 장치

### 하드디스크 HDD

- spindle(실린더의 축)에 여러 개의 platter가 고정
- sector: 하드디스크의 가장 작은 저장 단위로, platter에 존재
- block: 여러 개의 섹터로 구성
    - 블록마다 주소가 배정
        - 메모리에서는 하나의 바이트마다 주소 배정이지만, **운영체제 단위에서는 데이터 이동의 가장 작은 단위가 블록**
- read/write head:  디스크암에 있고, 플래터가 회전할 때 데이터를 읽거나 씀

- 데이터 전송에 걸리는 시간 = seek time + rotational latency time + transmission time
    - **seek time**: 원하는 특정 섹터가 있는 트랙을 만날 때까지 헤드가 이동하는데에 걸리는 시간
        - 셋 중 제일 오래 걸림 → 최소화 위해 여러 디스크 스케줄링 기법 중 선택
    - **rotational latency time**: 트랙도착 후에 특정 섹터 만날 때까지 기다리는 시간
    - **transmission time**: 특정 섹터의 데이터를 읽어 전송하는에 걸리는 시간

- **partition**: 하드디스크를 분할해서 사용하는 것. 다만 유닉스에서는 분할한 하드디스크들을 하나의 파티션으로 통합해서 보여줌(mount)
    - **formatting**: 파티션이 결정된 이후에, 디스크에 파일시스템을 탑재하고 디스크표면을 초기화해서 사용할 수 있는 형태로 바꿈
        - 파일 테이블: 디스크에서의 각 파일들의 위치와 크기 정보 저장하는 테이블
            - 빈 디스크에 파일테이블을 탑재하는 것이 포맷팅(느린 포맷팅)
                - cf. 빠른 포맷팅: 파일테이블을 초기화하는 것
- 조각모음: 이용하다보면 하드디스크에 디스크의 단편들이 생김 → 단편들을 모아 효율 증대

### SSD

- 플래시 메모리 사용 → 물리적으로 디스크가 회전하는 HDD보다 빠르고 가볍고, 비쌈

### 네트워크 저장장치

- 각 로컬의 저장장치의 파일들을 모아서 중앙에서 관리하는 것
- 구성 방식에 따라 DAS, NAS, SAN으로 구분
    - DAS(Directed Attached Storage) = HAS(Host Attached Storage)
        - 중앙 서버에 저장장치가 직접적으로 연결 → 로컬의 운영체제와 DAS의 운영체제가 같아야 이용 가능
    - NAS(Network Attached Storage)
        - 저장장치를 LAN, WAN에 붙여서 사용
            - 예시: 무선 공유기에 연결된 프린터는 컴퓨터와 유선 연결 없이 이용 가능
    - SAN(Storage Area Network)
        - NAS처럼 저장장치를 네트워크로 묶고, 데이트에 접근 위한 인터페이스를 생성

# 3. 디스크 스케쥴링 방법

- FCFS 스케줄링: 요청이 들어온 트랙 순서대로 트랙에 접근
- SSTF(Shortest Seek TIme First): 현재 헤드가 있는 위치에서 가장 가까운 트랙부터 접근
    - 헤드로부터 먼 트랙은 아사현상 발생 가능
- Block SSTF: 블록을 묶고, 현재 헤드로부터 가까운 트랙부터 블록 큐 생성
    - 에이징으로 공평성은 나아졌지만, 성능은 FCFS만큼 안 좋음
- SCAN: 헤드가 한 방향으로만 이동/ 아사현상 발생 가능
- C-SCAN: 한 방향으로 갔다가 다른 방향 갈 때는 작업 없이 이동/아사현상 발생 가능
- LOOK: SCAN처럼 한 방향으로 이동하다가 더 이상 그 방향에 서비스할 트랙 없으면 중간에서 회전
- C-LOOK: C-SAN + LOOK
- SLTF(Shortes Latency Time First): 고정헤드를 사용 → 헤드를 움직이지 않기에 빠름/ 비쌈

# 4. RAID

- RAID(Redundant Arrya of Independent Disks)의 기능
    - 데이터 복구: 원본 디스크와 같은 백업 디스크에 같은 내용 동시 저장 후 고장났을 때 백업디스크 이용해서 복구하는 시스템(mirroring)
    - 입출력 속도 증진: 데이터를  여러 조각으로 나누어서 각 디스크에 각각 저장(striping)→ 입출력 속도 개선
- 분류
    - RAID 0(스트라이핑): 빠름/ 복구는 안됨
    - RAID 1(미러링): 원본과 동일하게 백업 디스크도 구성 → 백업으로 인한 비용과 동일한 데이터의 두번 저장위한 속도 저하 발생 가능

<br/>

## 출처
- 조성호, 쉽게 배우는 운영체제(한빛아카데미, 2022)