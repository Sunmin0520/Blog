---
title: '[CS][OS] 가상 메모리 개요'
date: 2022-06-05 10:00:07
category: 'cs'
draft: false
---

# 1. 가상메모리

- 현대에는 가상메모리의 개념으로 **물리 메모리 크기와 관계없이 프로세스를 실행시킬 수 있다.**
    - 가상 메모리의 주소: 물리 메모리 공간이 아닌 가상의 주소 공간
    - 가상 메모리의 크기 ≤ 물리메모리의 최대 크기이지만,
        - **가상메모리가 사용할 수 있는 크기 = 물리 메모리 + 스왑영역**
    - **동적 변환** Dynamin Address Translation, DAT: 메모리 관리자는 가상 메모리에서 프로세스가 사용하는 주소를 실제 메모리 주소로 변환
    - **가상 메모리의 분할은 세그먼테이션-페이징 혼용기법을 주로 사용**
        - mapping table로 프로세스와 그 프로세스가 있는 위치(물리메모리 or swap) 확인
    
  <img src="https://user-images.githubusercontent.com/79896443/172032529-ab2ac601-8698-4f7d-850a-71800c1a45be.jpg" width="500">
    

# 2. 페이징

- **frame**: 가상메모리와의 페이지와의 구분 위해 **물리메모리의 영역**은 프레임이라고 호칭(페이지와 프레임의 크기 동일)

### **page (mapping) table**

- 페이지와 프레임의 연관 관계 표현
    - 스왑 영역에 있으면 프레임에서 invalid 로 표현
    - 페이지 테이블 통해 프로세스가 물리메모리에서 정보 읽어올 수 있음
        - 페이지 테이블에는 프레임 정보만 표현(페이지는 0부터 순서대로 저장되어 있기에)
    - 물리메모리의 운영체제 영역에 있음
    - 각각의 열을 부르는 호칭은 Page Table Entry, **PTE**
    - 각 PTE가 메모리를 차지하고, **모든 프로세스가 각각의 테이블과 가상메모리 가짐**→ **물리메모리의 크기가 작으면 스왑영역으로 프로세스와 페이지 테이블의 일부도 함께 옮겨짐**
    - 메모리 관리자는 **페이지 테이블 기준 레지스터** Page Table Base Resister, PTBR 에 각 PTE의 **시작 주소**를 보관 (페이지테이블에서의 위치를 빨리 파악 위해)
    
      <img src="https://user-images.githubusercontent.com/79896443/172032531-40659cd4-0848-4a95-8c81-459a81b886be.jpg" width="600">

    - 주소 변환: VA=<P,D> → PA=<F,D>
    
  <br>

- 매핑하는 방법
    - **직접 매핑** direct mapping: 페이지 테이블 전체가 물리메모리에 존재 → 별도 과정 없이 바로 전환 가능
    - **연관  매핑** associative: 페이지 테이블 전체가 스왑 영역에 존재하고,  전체 중 무작위 일부(변환 색인 버퍼Translation Look-aside Buffer, TLB or associate register 만 물리 메모리에 가지고 있음)
        → 원하는 페이지 번호가 TLB에 있으면 TBL hit → 물리 주소로 변환  
        → 없으면 TLB miss → 스왑영역의 테이블에서 직접매핑으로 물리 주소로 변환
        
      <img src="https://user-images.githubusercontent.com/79896443/172032533-9711662e-5b86-4075-b58d-9ff547eec879.jpg" width="500">
        
    - **집합-연관 매핑** set-associative: 페이지 테이블을 5개씩 자름 → 이 페이지 테이블에서 나타내는 프레임이 물리메모리에 있는지 or 스왑영역에 있는지 알려주는 집합 테이블 set table 생성  
    → 검색할 필요 없어 시간 단축

      <img src="https://user-images.githubusercontent.com/79896443/172032535-dc40b124-4bf9-4cf4-a092-50d72b1c7b15.jpg" width="500">
        
    - **역매핑**invert mapping
        - 직접, 연관, 집합연관에서 페이지 번호 기준으로 테이블 구성했던 것과 달리, **프레임 번호 기준으로 사용**
            - 장점: 모든 프로세스를 한 테이블에 담을 수 있어서 테이블 용량 작다(프레임 번호, PID, 페이지번호)
            - 단점: 특정 프로세스의 특정 페이지가 메모리에 있는지 확인하려면 그 정보를 테이블에서 찾고, 모든 페이지를 검색해야함 → 느림

# 3. 세그먼테이션

- segmentation (mapping) table: 페이지, 세그먼트의 크기(limit), 물리 메모리의 시작주소(address)로 구성
    - 장점: 메모리를 프로세스 단위로 관리 → 테이블 관리 편리
    - 단점: 물리메모리의 외부 단편화 → 물리 메모리 관리 복잡
- 주소 변환: VA=<S,D> → 변환한 물리주소 크기 < 각 limit → 해당 물리 주소에 접근
                      변환한 물리주소 크기 > 각 limit → 메모리 오류(trap: limit을 벗어나는 주소에 접근 등의 인터럽트)
    
# 4. 세그먼테이션-페이징 혼용

- paging: 메모리 관리 쉽다/ 테이블 크기 크다
- sementation: 메모리 관리 어렵다/ 테이블 크기 작다
- sementation-paging table
    - 각 프로세스의 메모리 접근 권한을 테이블에 추가
    - 관련있는 영역을 하나의 세그먼트로 묶어서 세그먼테이션 테이블로 관리
    - 각 세그먼트를 구성하는 페이지를 페이지테이블로 관리
- 주소 변환: VA=<S, P, D>

  <img src="https://user-images.githubusercontent.com/79896443/172032536-b8aaf6d8-8c33-49ab-99c5-2056f8104248.jpg" width="500">


<br/>

## 출처
- 조성호, 쉽게 배우는 운영체제(한빛아카데미, 2022)