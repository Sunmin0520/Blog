---
title: '[CS][OS] 물리 메모리 관리'
date: 2022-06-04 13:01:07
category: 'cs'
draft: false
---

# 1. 물리 메모리

- 캐시, (메인)메모리, 하드디스크의 **계층 구조**: 작업속도와 비용을 고려해서 프로그램은 메모리에서 실행
- **메모리 주소 레지스터 MAR**: CPU는 메모리에 있는 내용이나 작업결과 저장 위해 **MAR**에 **메모리의 주소값 넣음 (이 주소값을 이용해서 메모리에 접근)**
- 메모리 관리: 가져오기 fetch, 배치 placement, 재배치 replacement
    - fetch: 사용자의 요청에 따라 메모리 관리자가 프로세스와 데이터를 메모리로 가져옴
    - placment: 메모리의 구역을 나누고 프로세스와 데이터를 놓을 위치 결정
    - replacement: 교체 알고리즘을 통해 오래된 프로세스를 하드디스크로 옮겨놓음
  - 메모리관리 시스템 MMS에서 담당

# 2. 메모리 주소

- 32bit CPU: CPU가 한번에 다룰 수 있는 데이터의 최대 크기가 32bit
    - CPU 내부의 레지스터, ALU와 데이터를 전송하는(버스) 대역폭, 버스를 통해 한번에 옮겨지는 데이터 크기 모두 32bit이므로 운영체제도 이에 맞는 것을 설치
    - 메모리 주소의 범위: 0 ~ 2^23-1
    
- 메모리 중 운영체제 영역과 사용자 영역을 구분 필요: 영역침범 없는지 **CPU 레지스터**가 확인

### 메모리 중 사용자 영역의 주소를 구분하는 기준

- **절대주소:** 물리주소 0번지부터 시작/ 물리 주소 공간(실제 주소 공간)
- **상대주소**: 사용자가 사용할 수 있는 메모리 영역 기준으로 항상 0번지부터 시작/ 논리 주소 공간
- 절대주소에서 상대주소로의 변환
    - 상황: 운영체제 영역이 0~359, 사용자 영역이 360~999 사용할 때, 프로세스가 40번지의 데이터 필요
    - 변환
        1. 프로세스가 CPU에게 40번지의 데이터 요청
        2. CPU는 메모리 관리자에게 40번지의 데이터 가져올 것 명령
        3. 메모리 관리자는 **재배치 레지스터** 통해 40→400으로 변환 후 400번지의 데이터 가져옴
            - 재배치레지스터에는 사용자 영역이 시작되는 주소값 저장되어 있음
- 컴파일러는 변수를 메모리 주소로 바꾸어 기계어로 변환하고, 이 과정에서 주소는 상대주소 사용

# 3. 한 개의 프로세스가 실행될 때의 메모리 할당

- **메모리 오버레이**: 한정된 메모리 상황에서 메모리보다 큰 프로그램의 실행이 가능하게함
    - 상황: 프로그램 크기 > 실제 메모리크기 일 때
    - 해결: 프로그램을 몇 개의 모듈로 나누고 → 필요시마다 모듈 가져와서 사용
    
- **스왑** 영역: 사용하지 않는 데이터를 저장해두는 하드디스크의 공간/ 메모리 관리자가 관리
    - swap in: 스왑영역의 모듈 중 필요한 것을 메모리로 이동
    - swap out: 현재 안 필요한 모듈을 스왑영역으로 이동
    - 사용자가 인식하는 메모리 크기 = 실제 메모리 크기 + 스왑영역 크기

# 4. 여러 프로세스가 실행될 때의 메모리 할당

- 메모리에서 한 프로세스가 차지하는 크기를 분할하는 방식: 고정 VS 가변
- **현대에는 기본적으로 고정분할 방식 사용하면서 일부분은 가변 분할방식 혼합해서 사용**

### **고정 분할방식** fixed-size partitioning
- **paging**으로 메모리 할당
- **비연속적 메모리 할당**: 프로세스 크기 관계없이 메모리가 동일한 크기로 분할 → 한 프로세스가 여러 조각으로 나뉘어져 배치
- **내부 단편화**: 프로세스보다 큰 메모리 할당 → 메모리 안에서 프로세스 사이의 빈 공간 생김
    - 해결 방법: 메모리를 나누는 크기를 최적으로 선택

### **가변 분할방식** variable-size partitioning
- **segmentaion**으로 메모리 할당
- **연속 메모리 할당** continuos memory allocation: 프로세스의 크기만큼 메모리 분할 → 한 프로세스가 연속적으로 배치
- **외부 단편화** external fragmentation: 연속적으로 할당될 수 있을만한 메모리 공간이 안 나오면 그 메모리공간은 사용 못함 → 메모리 안에서 프로세스 사이에 빈 공간의 조각 생김
    - 해결 방법
        - 메모리 배치방식memory placement strategy: 메모리에 할당시 진행
            - 최초 배치 firtst fit: 메모리의 빈 공간에 프로세스를 **순서대로** 배치
            - 최적 배치 best fit: 메모리 빈 공간 모두 확보 후 **가장 최적으로** 작은 조각 안 생기게 배치
        - 조각모음 defragmentation: 프로세스가 종료된 이후에 진행
            - 남아있는 프로세스들의 동작을 멈춤 → 적당한 공간으로  메모리 상대주소값을 바꾸어서 자리 이동 → 단편화된 공간들을 합침

### 버디 시스템

- 필요한만큼의 메모리(가변)를 할당. 이 과정에서 1/2씩 잘라가면서 필요한 위치를 판단 → 메모리 관리가 고정보다는 복잡
- 1/2씩 잘라가면서 할당하기에 그 공간이 다른 프로세스가 차지하고 남은 것이면 사용 못함(고정 분할방식처럼 내부단편화)
- 비슷한 크기의 메모리 조각들이 인접 → 프로세스가 종료된 이후의 조각 모음이 가변분할방식보다 수월

<br/>

## 출처
- 조성호, 쉽게 배우는 운영체제(한빛아카데미, 2022)